/-
Copyright (c) 2022 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import topology.instances.irrational
import topology.algebra.order.archimedean
import topology.paracompact
import topology.metric_space.metrizable
import topology.metric_space.emetric_paracompact
import data.set.intervals.monotone

/-!
# Sorgenfrey line

In this file we define `sorgenfrey_line` (notation: `‚Ñù‚Çó`) to be the Sorgenfrey line. It is the real
line with the topology space structure generated by half-open intervals `set.Ico a b`.

We prove that this line is a completely normal Hausdorff space but its product with itself is not a
normal space. In particular, this implies that the topology on `‚Ñù‚Çó` is neither metrizable, nor
second countable.

## Notations

- `‚Ñù‚Çó`: Sorgenfrey line.

## TODO

Prove that the Sorgenfrey line is a paracompact space.

-/

open set filter topological_space
open_locale topology filter
namespace counterexample

noncomputable theory

/-- The Sorgenfrey line. It is the real line with the topology space structure generated by
half-open intervals `set.Ico a b`. -/
@[derive [conditionally_complete_linear_order, linear_ordered_field, archimedean]]
def sorgenfrey_line : Type := ‚Ñù

localized "notation (name := sorgenfrey_line) `‚Ñù‚Çó` := sorgenfrey_line" in sorgenfrey_line

namespace sorgenfrey_line

/-- Ring homomorphism between the Sorgenfrey line and the standard real line. -/
def to_real : ‚Ñù‚Çó ‚âÉ+* ‚Ñù := ring_equiv.refl ‚Ñù

instance : topological_space ‚Ñù‚Çó :=
topological_space.generate_from {s : set ‚Ñù‚Çó | ‚àÉ a b : ‚Ñù‚Çó, Ico a b = s}

lemma is_open_Ico (a b : ‚Ñù‚Çó) : is_open (Ico a b) :=
topological_space.generate_open.basic _ ‚ü®a, b, rfl‚ü©

lemma is_open_Ici (a : ‚Ñù‚Çó) : is_open (Ici a) :=
Union_Ico_right a ‚ñ∏ is_open_Union (is_open_Ico a)

lemma nhds_basis_Ico (a : ‚Ñù‚Çó) : (ùìù a).has_basis (Œª b, a < b) (Œª b, Ico a b) :=
begin
  rw topological_space.nhds_generate_from,
  haveI : nonempty {x // x ‚â§ a} := set.nonempty_Iic_subtype,
  have : (‚®Ö (x : {i // i ‚â§ a}), ùìü (Ici ‚Üëx)) = ùìü (Ici a),
  { refine (is_least.is_glb _).infi_eq,
    exact ‚ü®‚ü®‚ü®a, le_rfl‚ü©, rfl‚ü©, forall_range_iff.2 $
      Œª b, principal_mono.2 $ Ici_subset_Ici.2 b.2‚ü©, },
  simp only [mem_set_of_eq, infi_and, infi_exists, @infi_comm _ (_ ‚àà _),
    @infi_comm _ (set ‚Ñù‚Çó), infi_infi_eq_right],
  simp_rw [@infi_comm _ ‚Ñù‚Çó (_ ‚â§ _), infi_subtype', ‚Üê Ici_inter_Iio, ‚Üê inf_principal, ‚Üê inf_infi,
    ‚Üê infi_inf, this, infi_subtype],
  suffices : (‚®Ö x ‚àà Ioi a, ùìü (Iio x)).has_basis ((<) a) Iio, from this.principal_inf _,
  refine has_basis_binfi_principal _ nonempty_Ioi,
  exact directed_on_iff_directed.2 (directed_of_inf $ Œª x y hxy, Iio_subset_Iio hxy),
end

lemma nhds_basis_Ico_rat (a : ‚Ñù‚Çó) :
  (ùìù a).has_countable_basis (Œª r : ‚Ñö, a < r) (Œª r, Ico a r) :=
begin
  refine ‚ü®(nhds_basis_Ico a).to_has_basis (Œª b hb, _) (Œª r hr, ‚ü®_, hr, subset.rfl‚ü©),
    set.to_countable _‚ü©,
  rcases exists_rat_btwn hb with ‚ü®r, har, hrb‚ü©,
  exact ‚ü®r, har, Ico_subset_Ico_right hrb.le‚ü©
end

lemma nhds_basis_Ico_inv_pnat (a : ‚Ñù‚Çó) :
  (ùìù a).has_basis (Œª n : ‚Ñï+, true) (Œª n, Ico a (a + n‚Åª¬π)) :=
begin
  refine (nhds_basis_Ico a).to_has_basis (Œª b hb, _)
    (Œª n hn, ‚ü®_, lt_add_of_pos_right _ (inv_pos.2 $ nat.cast_pos.2 n.pos), subset.rfl‚ü©),
  rcases exists_nat_one_div_lt (sub_pos.2 hb) with ‚ü®k, hk‚ü©,
  rw [one_div] at hk,
  rw [‚Üê nat.cast_add_one] at hk,
  exact ‚ü®k.succ_pnat, trivial, Ico_subset_Ico_right (le_sub_iff_add_le'.1 hk.le)‚ü©
end

lemma nhds_countable_basis_Ico_inv_pnat (a : ‚Ñù‚Çó) :
  (ùìù a).has_countable_basis (Œª n : ‚Ñï+, true) (Œª n, Ico a (a + n‚Åª¬π)) :=
‚ü®nhds_basis_Ico_inv_pnat a, set.to_countable _‚ü©

lemma nhds_antitone_basis_Ico_inv_pnat (a : ‚Ñù‚Çó) :
  (ùìù a).has_antitone_basis (Œª n : ‚Ñï+, Ico a (a + n‚Åª¬π)) :=
‚ü®nhds_basis_Ico_inv_pnat a, monotone_const.Ico $
  antitone.const_add (Œª k l hkl, inv_le_inv_of_le (nat.cast_pos.2 k.pos) (nat.mono_cast hkl)) _‚ü©

lemma is_open_iff {s : set ‚Ñù‚Çó} : is_open s ‚Üî ‚àÄ x ‚àà s, ‚àÉ y > x, Ico x y ‚äÜ s :=
is_open_iff_mem_nhds.trans $ forall‚ÇÇ_congr $ Œª x hx, (nhds_basis_Ico x).mem_iff

lemma is_closed_iff {s : set ‚Ñù‚Çó} : is_closed s ‚Üî ‚àÄ x ‚àâ s, ‚àÉ y > x, disjoint (Ico x y) s :=
by simp only [‚Üê is_open_compl_iff, is_open_iff, mem_compl_iff, subset_compl_iff_disjoint_right]

lemma exists_Ico_disjoint_closed {a : ‚Ñù‚Çó} {s : set ‚Ñù‚Çó} (hs : is_closed s) (ha : a ‚àâ s) :
  ‚àÉ b > a, disjoint (Ico a b) s :=
is_closed_iff.1 hs a ha

@[simp] lemma map_to_real_nhds (a : ‚Ñù‚Çó) : map to_real (ùìù a) = ùìù[‚â•] (to_real a) :=
begin
  refine ((nhds_basis_Ico a).map _).eq_of_same_basis _,
  simpa only [to_real.image_eq_preimage] using nhds_within_Ici_basis_Ico (to_real a)
end

lemma nhds_eq_map (a : ‚Ñù‚Çó) : ùìù a = map to_real.symm (ùìù[‚â•] a.to_real) :=
by simp_rw [‚Üê map_to_real_nhds, map_map, (‚àò), to_real.symm_apply_apply, map_id']

lemma nhds_eq_comap (a : ‚Ñù‚Çó) : ùìù a = comap to_real (ùìù[‚â•] a.to_real) :=
by rw [‚Üê map_to_real_nhds, comap_map to_real.injective]

@[continuity] lemma continuous_to_real : continuous to_real :=
continuous_iff_continuous_at.2 $ Œª x,
  by { rw [continuous_at, tendsto, map_to_real_nhds], exact inf_le_left }

instance : order_closed_topology ‚Ñù‚Çó :=
‚ü®is_closed_le_prod.preimage (continuous_to_real.prod_map continuous_to_real)‚ü©

instance : has_continuous_add ‚Ñù‚Çó :=
begin
  refine ‚ü®continuous_iff_continuous_at.2 _‚ü©,
  rintro ‚ü®x, y‚ü©,
  simp only [continuous_at, nhds_prod_eq, nhds_eq_map, nhds_eq_comap (x + y), prod_map_map_eq,
    tendsto_comap_iff, tendsto_map'_iff, (‚àò), ‚Üê nhds_within_prod_eq],
  exact (continuous_add.tendsto _).inf (maps_to.tendsto $ Œª x hx, add_le_add hx.1 hx.2)
end

lemma is_clopen_Ici (a : ‚Ñù‚Çó) : is_clopen (Ici a) := ‚ü®is_open_Ici a, is_closed_Ici‚ü©

lemma is_clopen_Iio (a : ‚Ñù‚Çó) : is_clopen (Iio a) :=
by simpa only [compl_Ici] using (is_clopen_Ici a).compl

lemma is_clopen_Ico (a b : ‚Ñù‚Çó) : is_clopen (Ico a b) :=
(is_clopen_Ici a).inter (is_clopen_Iio b)

instance : totally_disconnected_space ‚Ñù‚Çó :=
‚ü®Œª s hs' hs x hx y hy, le_antisymm (hs.subset_clopen (is_clopen_Ici x) ‚ü®x, hx, le_rfl‚ü© hy)
  (hs.subset_clopen (is_clopen_Ici y) ‚ü®y, hy, le_rfl‚ü© hx)‚ü©

instance : first_countable_topology ‚Ñù‚Çó := ‚ü®Œª x, (nhds_basis_Ico_rat x).is_countably_generated‚ü©

/-- Sorgenfrey line is a completely normal Hausdorff topological space. -/
instance : t5_space ‚Ñù‚Çó :=
begin
  /- Let `s` and `t` be disjoint closed sets. For each `x ‚àà s` we choose `X x` such that
  `set.Ico x (X x)` is disjoint with `t`. Similarly, for each `y ‚àà t` we choose `Y y` such that
  `set.Ico y (Y y)` is disjoint with `s`. Then `‚ãÉ x ‚àà s, Ico x (X x)` and `‚ãÉ y ‚àà t, Ico y (Y y)` are
  disjoint open sets that include `s` and `t`. -/
  refine ‚ü®Œª s t hd‚ÇÅ hd‚ÇÇ, _‚ü©,
  choose! X hX hXd
    using Œª x (hx : x ‚àà s), exists_Ico_disjoint_closed is_closed_closure (disjoint_left.1 hd‚ÇÇ hx),
  choose! Y hY hYd
    using Œª y (hy : y ‚àà t), exists_Ico_disjoint_closed is_closed_closure (disjoint_right.1 hd‚ÇÅ hy),
  refine disjoint_of_disjoint_of_mem _
    (bUnion_mem_nhds_set $ Œª x hx, (is_open_Ico x (X x)).mem_nhds $ left_mem_Ico.2 (hX x hx))
    (bUnion_mem_nhds_set $ Œª y hy, (is_open_Ico y (Y y)).mem_nhds $ left_mem_Ico.2 (hY y hy)),
  simp only [disjoint_Union_left, disjoint_Union_right, Ico_disjoint_Ico],
  intros y hy x hx,
  cases le_total x y with hle hle,
  { calc min (X x) (Y y) ‚â§ X x : min_le_left _ _
    ... ‚â§ y : not_lt.1 (Œª hyx, (hXd x hx).le_bot ‚ü®‚ü®hle, hyx‚ü©, subset_closure hy‚ü©)
    ... ‚â§ max x y : le_max_right _ _ },
  { calc min (X x) (Y y) ‚â§ Y y : min_le_right _ _
    ... ‚â§ x : not_lt.1 $ Œª hxy, (hYd y hy).le_bot ‚ü®‚ü®hle, hxy‚ü©, subset_closure hx‚ü©
    ... ‚â§ max x y : le_max_left _ _ }
end

lemma dense_range_coe_rat : dense_range (coe : ‚Ñö ‚Üí ‚Ñù‚Çó) :=
begin
  refine dense_iff_inter_open.2 _,
  rintro U Uo ‚ü®x, hx‚ü©,
  rcases is_open_iff.1 Uo _ hx with ‚ü®y, hxy, hU‚ü©,
  rcases exists_rat_btwn hxy with ‚ü®z, hxz, hzy‚ü©,
  exact ‚ü®z, hU ‚ü®hxz.le, hzy‚ü©, mem_range_self _‚ü©
end

instance : separable_space ‚Ñù‚Çó := ‚ü®‚ü®_, countable_range _, dense_range_coe_rat‚ü©‚ü©

lemma is_closed_antidiagonal (c : ‚Ñù‚Çó) : is_closed {x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = c} :=
is_closed_singleton.preimage continuous_add

lemma is_clopen_Ici_prod (x : ‚Ñù‚Çó √ó ‚Ñù‚Çó) : is_clopen (Ici x) :=
(Ici_prod_eq x).symm ‚ñ∏ (is_clopen_Ici _).prod (is_clopen_Ici _)

/-- Any subset of an antidiagonal `{(x, y) : ‚Ñù‚Çó √ó ‚Ñù‚Çó| x + y = c}` is a closed set. -/
lemma is_closed_of_subset_antidiagonal {s : set (‚Ñù‚Çó √ó ‚Ñù‚Çó)} {c : ‚Ñù‚Çó}
  (hs : ‚àÄ x : ‚Ñù‚Çó √ó ‚Ñù‚Çó, x ‚àà s ‚Üí x.1 + x.2 = c) : is_closed s :=
begin
  rw [‚Üê closure_subset_iff_is_closed],
  rintro ‚ü®x, y‚ü© H,
  obtain rfl : x + y = c,
  { change (x, y) ‚àà {p : ‚Ñù‚Çó √ó ‚Ñù‚Çó | p.1 + p.2 = c},
    exact closure_minimal (hs : s ‚äÜ {x | x.1 + x.2 = c}) (is_closed_antidiagonal c) H },
  rcases mem_closure_iff.1 H (Ici (x, y)) (is_clopen_Ici_prod _).1 le_rfl
    with ‚ü®‚ü®x', y'‚ü©, ‚ü®hx : x ‚â§ x', hy : y ‚â§ y'‚ü©, H‚ü©,
  convert H,
  { refine hx.antisymm _,
    rwa [‚Üê add_le_add_iff_right, hs _ H, add_le_add_iff_left] },
  { refine hy.antisymm _,
    rwa [‚Üê add_le_add_iff_left, hs _ H, add_le_add_iff_right] }
end

lemma nhds_prod_antitone_basis_inv_pnat (x y : ‚Ñù‚Çó) :
  (ùìù (x, y)).has_antitone_basis (Œª n : ‚Ñï+, Ico x (x + n‚Åª¬π) √óÀ¢ Ico y (y + n‚Åª¬π)) :=
begin
  rw [nhds_prod_eq],
  exact (nhds_antitone_basis_Ico_inv_pnat x).prod (nhds_antitone_basis_Ico_inv_pnat y)
end

/-- The product of the Sorgenfrey line and itself is not a normal topological space. -/
lemma not_normal_space_prod : ¬¨normal_space (‚Ñù‚Çó √ó ‚Ñù‚Çó) :=
begin
  have h‚ÇÄ : ‚àÄ {n : ‚Ñï+}, (0 : ‚Ñù) < n‚Åª¬π, from Œª n, inv_pos.2 (nat.cast_pos.2 n.pos),
  have h‚ÇÄ' : ‚àÄ {n : ‚Ñï+} {x : ‚Ñù}, x < x + n‚Åª¬π, from Œª n x, lt_add_of_pos_right _ h‚ÇÄ,
  introI,
  /- Let `S` be the set of points `(x, y)` on the line `x + y = 0` such that `x` is rational.
  Let `T` be the set of points `(x, y)` on the line `x + y = 0` such that `x` is irrational.
  These sets are closed, see `sorgenfrey_line.is_closed_of_subset_antidiagonal`, and disjoint. -/
  set S := {x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = 0 ‚àß ‚àÉ r : ‚Ñö, ‚Üër = x.1},
  set T := {x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = 0 ‚àß irrational x.1.to_real},
  have hSc : is_closed S, from is_closed_of_subset_antidiagonal (Œª x hx, hx.1),
  have hTc : is_closed T, from is_closed_of_subset_antidiagonal (Œª x hx, hx.1),
  have hd : disjoint S T,
  { rw disjoint_iff_inf_le,
    rintro ‚ü®x, y‚ü© ‚ü®‚ü®-, r, rfl : _ = x‚ü©, -, hr‚ü©,
    exact r.not_irrational hr },
  /- Consider disjoint open sets `U ‚äá S` and `V ‚äá T`. -/
  rcases normal_separation hSc hTc hd with ‚ü®U, V, Uo, Vo, SU, TV, UV‚ü©,
  /- For each point `(x, -x) ‚àà T`, choose a neighborhood
  `Ico x (x + k‚Åª¬π) √óÀ¢ Ico (-x) (-x + k‚Åª¬π) ‚äÜ V`. -/
  have : ‚àÄ x : ‚Ñù‚Çó, irrational x.to_real ‚Üí
    ‚àÉ k : ‚Ñï+, Ico x (x + k‚Åª¬π) √óÀ¢ Ico (-x) (-x + k‚Åª¬π) ‚äÜ V,
  { intros x hx,
    have hV : V ‚àà ùìù (x, -x), from Vo.mem_nhds (@TV (x, -x) ‚ü®add_neg_self x, hx‚ü©),
    exact (nhds_prod_antitone_basis_inv_pnat _ _).mem_iff.1 hV },
  choose! k hkV,
  /- Since the set of irrational numbers is a dense GŒ¥ set in the usual topology of `‚Ñù`, there
  exists `N > 0` such that the set `C N = {x : ‚Ñù | irrational x ‚àß k x = N}` is dense in a nonempty
  interval. In other words, the closure of this set has a nonempty interior. -/
  set C : ‚Ñï+ ‚Üí set ‚Ñù := Œª n, closure {x | irrational x ‚àß k (to_real.symm x) = n},
  have H : {x : ‚Ñù | irrational x} ‚äÜ ‚ãÉ n, C n,
    from Œª x hx, mem_Union.2 ‚ü®_, subset_closure ‚ü®hx, rfl‚ü©‚ü©,
  have Hd : dense (‚ãÉ n, interior (C n)) :=
    is_GŒ¥_irrational.dense_Union_interior_of_closed dense_irrational (Œª _, is_closed_closure) H,
  obtain ‚ü®N, hN‚ü© : ‚àÉ n : ‚Ñï+, (interior $ C n).nonempty, from nonempty_Union.mp Hd.nonempty,
  /- Choose a rational number `r` in the interior of the closure of `C N`, then choose `n ‚â• N > 0`
  such that `Ico r (r + n‚Åª¬π) √ó Ico (-r) (-r + n‚Åª¬π) ‚äÜ U`. -/
  rcases rat.dense_range_cast.exists_mem_open is_open_interior hN with ‚ü®r, hr‚ü©,
  have hrU : ((r, -r) : ‚Ñù‚Çó √ó ‚Ñù‚Çó) ‚àà U, from @SU (r, -r) ‚ü®add_neg_self _, r, rfl‚ü©,
  obtain ‚ü®n, hnN, hn‚ü© : ‚àÉ n  (hnN : N ‚â§ n), Ico (r : ‚Ñù‚Çó) (r + n‚Åª¬π) √óÀ¢ Ico (-r : ‚Ñù‚Çó) (-r + n‚Åª¬π) ‚äÜ U,
    from ((nhds_prod_antitone_basis_inv_pnat _ _).has_basis_ge N).mem_iff.1 (Uo.mem_nhds hrU),
  /- Finally, choose `x ‚àà Ioo (r : ‚Ñù) (r + n‚Åª¬π) ‚à© C N`. Then `(x, -r)` belongs both to `U` and `V`,
  so they are not disjoint. This contradiction completes the proof. -/
  obtain ‚ü®x, hxn, hx_irr, rfl‚ü© :
    ‚àÉ x : ‚Ñù, x ‚àà Ioo (r : ‚Ñù) (r + n‚Åª¬π) ‚àß irrational x ‚àß k (to_real.symm x) = N,
  { have : (r : ‚Ñù) ‚àà closure (Ioo (r : ‚Ñù) (r + n‚Åª¬π)),
    { rw [closure_Ioo h‚ÇÄ'.ne, left_mem_Icc], exact h‚ÇÄ'.le },
    rcases mem_closure_iff_nhds.1 this _ (mem_interior_iff_mem_nhds.1 hr) with ‚ü®x', hx', hx'Œµ‚ü©,
    exact mem_closure_iff.1 hx' _ is_open_Ioo hx'Œµ },
  refine UV.le_bot (_ : (to_real.symm x, -‚Üër) ‚àà _),
  refine ‚ü®hn ‚ü®_, _‚ü©, hkV (to_real.symm x) hx_irr ‚ü®_, _‚ü©‚ü©,
  { exact Ioo_subset_Ico_self hxn },
  { exact left_mem_Ico.2 h‚ÇÄ' },
  { exact left_mem_Ico.2 h‚ÇÄ' },
  { refine (nhds_antitone_basis_Ico_inv_pnat (-x)).2 hnN ‚ü®neg_le_neg hxn.1.le, _‚ü©,
    simp only [add_neg_lt_iff_le_add', lt_neg_add_iff_add_lt],
    exact hxn.2 }
end

/-- Topology on the Sorgenfrey line is not metrizable. -/
lemma not_metrizable_space : ¬¨metrizable_space ‚Ñù‚Çó :=
begin
  introI,
  letI := metrizable_space_metric ‚Ñù‚Çó,
  exact not_normal_space_prod infer_instance
end

/-- Topology on the Sorgenfrey line is not second countable. -/
lemma not_second_countable_topology : ¬¨second_countable_topology ‚Ñù‚Çó :=
by { introI, exact not_metrizable_space (metrizable_space_of_t3_second_countable _) }

end sorgenfrey_line

end counterexample
