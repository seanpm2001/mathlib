/-
Copyright (c) 2020 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn
-/
import measure_theory.constructions.prod.basic
import measure_theory.integral.set_integral

/-!
# Integration with respect to the product measure

In this file we prove Fubini's theorem.

## Main results

* `measure_theory.integrable_prod_iff` states that a binary function is integrable iff both
  * `y ‚Ü¶ f (x, y)` is integrable for almost every `x`, and
  * the function `x ‚Ü¶ ‚à´ ‚Äñf (x, y)‚Äñ dy` is integrable.
* `measure_theory.integral_prod`: Fubini's theorem. It states that for a integrable function
  `Œ± √ó Œ≤ ‚Üí E` (where `E` is a second countable Banach space) we have
  `‚à´ z, f z ‚àÇ(Œº.prod ŒΩ) = ‚à´ x, ‚à´ y, f (x, y) ‚àÇŒΩ ‚àÇŒº`. This theorem has the same variants as
  Tonelli's theorem (see `measure_theory.lintegral_prod`). The lemma
  `measure_theory.integrable.integral_prod_right` states that the inner integral of the right-hand
  side is integrable.

## Tags

product measure, Fubini's theorem, Fubini-Tonelli theorem
-/

noncomputable theory
open_locale classical topology ennreal measure_theory
open set function real ennreal
open measure_theory measurable_space measure_theory.measure
open topological_space
open filter (hiding prod_eq map)

variables {Œ± Œ±' Œ≤ Œ≤' Œ≥ E : Type*}

variables [measurable_space Œ±] [measurable_space Œ±'] [measurable_space Œ≤] [measurable_space Œ≤']
variables [measurable_space Œ≥]
variables {Œº Œº' : measure Œ±} {ŒΩ ŒΩ' : measure Œ≤} {œÑ : measure Œ≥}
variables [normed_add_comm_group E]

/-! ### Measurability

Before we define the product measure, we can talk about the measurability of operations on binary
functions. We show that if `f` is a binary measurable function, then the function that integrates
along one of the variables (using either the Lebesgue or Bochner integral) is measurable.
-/

lemma measurable_set_integrable [sigma_finite ŒΩ] ‚¶Éf : Œ± ‚Üí Œ≤ ‚Üí E‚¶Ñ
  (hf : strongly_measurable (uncurry f)) : measurable_set {x | integrable (f x) ŒΩ} :=
begin
  simp_rw [integrable, hf.of_uncurry_left.ae_strongly_measurable, true_and],
  exact measurable_set_lt (measurable.lintegral_prod_right hf.ennnorm) measurable_const
end

section
variables [normed_space ‚Ñù E] [complete_space E]

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  Fubini's theorem is measurable.
  This version has `f` in curried form. -/
lemma measure_theory.strongly_measurable.integral_prod_right [sigma_finite ŒΩ] ‚¶Éf : Œ± ‚Üí Œ≤ ‚Üí E‚¶Ñ
  (hf : strongly_measurable (uncurry f)) : strongly_measurable (Œª x, ‚à´ y, f x y ‚àÇŒΩ) :=
begin
  borelize E,
  haveI : separable_space (range (uncurry f) ‚à™ {0} : set E) :=
    hf.separable_space_range_union_singleton,
  let s : ‚Ñï ‚Üí simple_func (Œ± √ó Œ≤) E := simple_func.approx_on _ hf.measurable
    (range (uncurry f) ‚à™ {0}) 0 (by simp),
  let s' : ‚Ñï ‚Üí Œ± ‚Üí simple_func Œ≤ E := Œª n x, (s n).comp (prod.mk x) measurable_prod_mk_left,
  let f' : ‚Ñï ‚Üí Œ± ‚Üí E := Œª n, {x | integrable (f x) ŒΩ}.indicator
    (Œª x, (s' n x).integral ŒΩ),
  have hf' : ‚àÄ n, strongly_measurable (f' n),
  { intro n, refine strongly_measurable.indicator _ (measurable_set_integrable hf),
    have : ‚àÄ x, (s' n x).range.filter (Œª x, x ‚â† 0) ‚äÜ (s n).range,
    { intros x, refine finset.subset.trans (finset.filter_subset _ _) _, intro y,
      simp_rw [simple_func.mem_range], rintro ‚ü®z, rfl‚ü©, exact ‚ü®(x, z), rfl‚ü© },
    simp only [simple_func.integral_eq_sum_of_subset (this _)],
    refine finset.strongly_measurable_sum _ (Œª x _, _),
    refine (measurable.ennreal_to_real _).strongly_measurable.smul_const _,
    simp only [simple_func.coe_comp, preimage_comp] {single_pass := tt},
    apply measurable_measure_prod_mk_left,
    exact (s n).measurable_set_fiber x },
  have h2f' : tendsto f' at_top (ùìù (Œª (x : Œ±), ‚à´ (y : Œ≤), f x y ‚àÇŒΩ)),
  { rw [tendsto_pi_nhds], intro x,
    by_cases hfx : integrable (f x) ŒΩ,
    { have : ‚àÄ n, integrable (s' n x) ŒΩ,
      { intro n, apply (hfx.norm.add hfx.norm).mono' (s' n x).ae_strongly_measurable,
        apply eventually_of_forall, intro y,
        simp_rw [s', simple_func.coe_comp], exact simple_func.norm_approx_on_zero_le _ _ (x, y) n },
      simp only [f', hfx, simple_func.integral_eq_integral _ (this _), indicator_of_mem,
        mem_set_of_eq],
      refine tendsto_integral_of_dominated_convergence (Œª y, ‚Äñf x y‚Äñ + ‚Äñf x y‚Äñ)
        (Œª n, (s' n x).ae_strongly_measurable) (hfx.norm.add hfx.norm) _ _,
      { exact Œª n, eventually_of_forall (Œª y, simple_func.norm_approx_on_zero_le _ _ (x, y) n) },
      { refine eventually_of_forall (Œª y, simple_func.tendsto_approx_on _ _ _),
        apply subset_closure,
        simp [-uncurry_apply_pair], } },
    { simp [f', hfx, integral_undef], } },
  exact strongly_measurable_of_tendsto _ hf' h2f'
end

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  Fubini's theorem is measurable. -/
lemma measure_theory.strongly_measurable.integral_prod_right' [sigma_finite ŒΩ] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : strongly_measurable f) : strongly_measurable (Œª x, ‚à´ y, f (x, y) ‚àÇŒΩ) :=
by { rw [‚Üê uncurry_curry f] at hf, exact hf.integral_prod_right }

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Fubini's theorem is measurable.
  This version has `f` in curried form. -/
lemma measure_theory.strongly_measurable.integral_prod_left [sigma_finite Œº] ‚¶Éf : Œ± ‚Üí Œ≤ ‚Üí E‚¶Ñ
  (hf : strongly_measurable (uncurry f)) : strongly_measurable (Œª y, ‚à´ x, f x y ‚àÇŒº) :=
(hf.comp_measurable measurable_swap).integral_prod_right'

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Fubini's theorem is measurable. -/
lemma measure_theory.strongly_measurable.integral_prod_left' [sigma_finite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : strongly_measurable f) : strongly_measurable (Œª y, ‚à´ x, f (x, y) ‚àÇŒº) :=
(hf.comp_measurable measurable_swap).integral_prod_right'

end

/-! ### The product measure -/

namespace measure_theory

namespace measure

variables [sigma_finite ŒΩ]

lemma integrable_measure_prod_mk_left {s : set (Œ± √ó Œ≤)}
  (hs : measurable_set s) (h2s : (Œº.prod ŒΩ) s ‚â† ‚àû) :
  integrable (Œª x, (ŒΩ (prod.mk x ‚Åª¬π' s)).to_real) Œº :=
begin
  refine ‚ü®(measurable_measure_prod_mk_left hs).ennreal_to_real.ae_measurable.ae_strongly_measurable,
    _‚ü©,
  simp_rw [has_finite_integral, ennnorm_eq_of_real to_real_nonneg],
  convert h2s.lt_top using 1, simp_rw [prod_apply hs], apply lintegral_congr_ae,
  refine (ae_measure_lt_top hs h2s).mp _, apply eventually_of_forall, intros x hx,
  rw [lt_top_iff_ne_top] at hx, simp [of_real_to_real, hx],
end

end measure

open measure

end measure_theory

open measure_theory.measure

section

lemma measure_theory.ae_strongly_measurable.prod_swap
  {Œ≥ : Type*} [topological_space Œ≥] [sigma_finite Œº] [sigma_finite ŒΩ] {f : Œ≤ √ó Œ± ‚Üí Œ≥}
  (hf : ae_strongly_measurable f (ŒΩ.prod Œº)) :
  ae_strongly_measurable (Œª (z : Œ± √ó Œ≤), f z.swap) (Œº.prod ŒΩ) :=
by { rw ‚Üê prod_swap at hf, exact hf.comp_measurable measurable_swap }

lemma measure_theory.ae_strongly_measurable.fst {Œ≥} [topological_space Œ≥] [sigma_finite ŒΩ]
  {f : Œ± ‚Üí Œ≥} (hf : ae_strongly_measurable f Œº) :
  ae_strongly_measurable (Œª (z : Œ± √ó Œ≤), f z.1) (Œº.prod ŒΩ) :=
hf.comp_quasi_measure_preserving quasi_measure_preserving_fst

lemma measure_theory.ae_strongly_measurable.snd {Œ≥} [topological_space Œ≥] [sigma_finite ŒΩ]
  {f : Œ≤ ‚Üí Œ≥} (hf : ae_strongly_measurable f ŒΩ) :
  ae_strongly_measurable (Œª (z : Œ± √ó Œ≤), f z.2) (Œº.prod ŒΩ) :=
hf.comp_quasi_measure_preserving quasi_measure_preserving_snd

/-- The Bochner integral is a.e.-measurable.
  This shows that the integrand of (the right-hand-side of) Fubini's theorem is a.e.-measurable. -/
lemma measure_theory.ae_strongly_measurable.integral_prod_right' [sigma_finite ŒΩ]
  [normed_space ‚Ñù E] [complete_space E]
  ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ (hf : ae_strongly_measurable f (Œº.prod ŒΩ)) :
  ae_strongly_measurable (Œª x, ‚à´ y, f (x, y) ‚àÇŒΩ) Œº :=
‚ü®Œª x, ‚à´ y, hf.mk f (x, y) ‚àÇŒΩ, hf.strongly_measurable_mk.integral_prod_right',
  by { filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk] with _ hx using integral_congr_ae hx }‚ü©

lemma measure_theory.ae_strongly_measurable.prod_mk_left
  {Œ≥ : Type*} [sigma_finite ŒΩ] [topological_space Œ≥] {f : Œ± √ó Œ≤ ‚Üí Œ≥}
  (hf : ae_strongly_measurable f (Œº.prod ŒΩ)) : ‚àÄ·µê x ‚àÇŒº, ae_strongly_measurable (Œª y, f (x, y)) ŒΩ :=
begin
  filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk] with x hx,
  exact ‚ü®Œª y, hf.mk f (x, y), hf.strongly_measurable_mk.comp_measurable measurable_prod_mk_left, hx‚ü©
end

end

namespace measure_theory

variables [sigma_finite ŒΩ]

/-! ### Integrability on a product -/
section

lemma integrable.swap [sigma_finite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) : integrable (f ‚àò prod.swap) (ŒΩ.prod Œº) :=
‚ü®hf.ae_strongly_measurable.prod_swap,
  (lintegral_prod_swap _ hf.ae_strongly_measurable.ennnorm : _).le.trans_lt hf.has_finite_integral‚ü©

lemma integrable_swap_iff [sigma_finite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ :
  integrable (f ‚àò prod.swap) (ŒΩ.prod Œº) ‚Üî integrable f (Œº.prod ŒΩ) :=
‚ü®Œª hf, by { convert hf.swap, ext ‚ü®x, y‚ü©, refl }, Œª hf, hf.swap‚ü©

lemma has_finite_integral_prod_iff ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ (h1f : strongly_measurable f) :
  has_finite_integral f (Œº.prod ŒΩ) ‚Üî (‚àÄ·µê x ‚àÇ Œº, has_finite_integral (Œª y, f (x, y)) ŒΩ) ‚àß
    has_finite_integral (Œª x, ‚à´ y, ‚Äñf (x, y)‚Äñ ‚àÇŒΩ) Œº :=
begin
  simp only [has_finite_integral, lintegral_prod_of_measurable _ h1f.ennnorm],
  have : ‚àÄ x, ‚àÄ·µê y ‚àÇŒΩ, 0 ‚â§ ‚Äñf (x, y)‚Äñ := Œª x, eventually_of_forall (Œª y, norm_nonneg _),
  simp_rw [integral_eq_lintegral_of_nonneg_ae (this _)
    (h1f.norm.comp_measurable measurable_prod_mk_left).ae_strongly_measurable,
    ennnorm_eq_of_real to_real_nonneg, of_real_norm_eq_coe_nnnorm],
  -- this fact is probably too specialized to be its own lemma
  have : ‚àÄ {p q r : Prop} (h1 : r ‚Üí p), (r ‚Üî p ‚àß q) ‚Üî (p ‚Üí (r ‚Üî q)) :=
  Œª p q r h1, by rw [‚Üê and.congr_right_iff, and_iff_right_of_imp h1],
  rw [this],
  { intro h2f, rw lintegral_congr_ae,
    refine h2f.mp _, apply eventually_of_forall, intros x hx, dsimp only,
    rw [of_real_to_real], rw [‚Üê lt_top_iff_ne_top], exact hx },
  { intro h2f, refine ae_lt_top _ h2f.ne, exact h1f.ennnorm.lintegral_prod_right' },
end

lemma has_finite_integral_prod_iff' ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ (h1f : ae_strongly_measurable f (Œº.prod ŒΩ)) :
  has_finite_integral f (Œº.prod ŒΩ) ‚Üî (‚àÄ·µê x ‚àÇ Œº, has_finite_integral (Œª y, f (x, y)) ŒΩ) ‚àß
    has_finite_integral (Œª x, ‚à´ y, ‚Äñf (x, y)‚Äñ ‚àÇŒΩ) Œº :=
begin
  rw [has_finite_integral_congr h1f.ae_eq_mk,
    has_finite_integral_prod_iff h1f.strongly_measurable_mk],
  apply and_congr,
  { apply eventually_congr,
    filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm],
    assume x hx,
    exact has_finite_integral_congr hx },
  { apply has_finite_integral_congr,
    filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm] with _ hx
      using integral_congr_ae (eventually_eq.fun_comp hx _), },
  { apply_instance, },
end

/-- A binary function is integrable if the function `y ‚Ü¶ f (x, y)` is integrable for almost every
  `x` and the function `x ‚Ü¶ ‚à´ ‚Äñf (x, y)‚Äñ dy` is integrable. -/
lemma integrable_prod_iff ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ (h1f : ae_strongly_measurable f (Œº.prod ŒΩ)) :
  integrable f (Œº.prod ŒΩ) ‚Üî
    (‚àÄ·µê x ‚àÇ Œº, integrable (Œª y, f (x, y)) ŒΩ) ‚àß integrable (Œª x, ‚à´ y, ‚Äñf (x, y)‚Äñ ‚àÇŒΩ) Œº :=
by simp [integrable, h1f, has_finite_integral_prod_iff', h1f.norm.integral_prod_right',
         h1f.prod_mk_left]

/-- A binary function is integrable if the function `x ‚Ü¶ f (x, y)` is integrable for almost every
  `y` and the function `y ‚Ü¶ ‚à´ ‚Äñf (x, y)‚Äñ dx` is integrable. -/
lemma integrable_prod_iff' [sigma_finite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (h1f : ae_strongly_measurable f (Œº.prod ŒΩ)) :
  integrable f (Œº.prod ŒΩ) ‚Üî
    (‚àÄ·µê y ‚àÇ ŒΩ, integrable (Œª x, f (x, y)) Œº) ‚àß integrable (Œª y, ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ :=
by { convert integrable_prod_iff (h1f.prod_swap) using 1, rw [integrable_swap_iff] }

lemma integrable.prod_left_ae [sigma_finite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) : ‚àÄ·µê y ‚àÇ ŒΩ, integrable (Œª x, f (x, y)) Œº :=
((integrable_prod_iff' hf.ae_strongly_measurable).mp hf).1

lemma integrable.prod_right_ae [sigma_finite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) : ‚àÄ·µê x ‚àÇ Œº, integrable (Œª y, f (x, y)) ŒΩ :=
hf.swap.prod_left_ae

lemma integrable.integral_norm_prod_left ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) : integrable (Œª x, ‚à´ y, ‚Äñf (x, y)‚Äñ ‚àÇŒΩ) Œº :=
((integrable_prod_iff hf.ae_strongly_measurable).mp hf).2

lemma integrable.integral_norm_prod_right [sigma_finite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) : integrable (Œª y, ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ :=
hf.swap.integral_norm_prod_left

lemma integrable_prod_mul {L : Type*} [is_R_or_C L]
  {f : Œ± ‚Üí L} {g : Œ≤ ‚Üí L} (hf : integrable f Œº) (hg : integrable g ŒΩ) :
  integrable (Œª (z : Œ± √ó Œ≤), f z.1 * g z.2) (Œº.prod ŒΩ) :=
begin
  refine (integrable_prod_iff _).2 ‚ü®_, _‚ü©,
  { exact hf.1.fst.mul hg.1.snd },
  { exact eventually_of_forall (Œª x, hg.const_mul (f x)) },
  { simpa only [norm_mul, integral_mul_left] using hf.norm.mul_const _ }
end

end

variables [normed_space ‚Ñù E] [complete_space E]

lemma integrable.integral_prod_left ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) : integrable (Œª x, ‚à´ y, f (x, y) ‚àÇŒΩ) Œº :=
integrable.mono hf.integral_norm_prod_left hf.ae_strongly_measurable.integral_prod_right' $
  eventually_of_forall $ Œª x, (norm_integral_le_integral_norm _).trans_eq $
  (norm_of_nonneg $ integral_nonneg_of_ae $ eventually_of_forall $
  Œª y, (norm_nonneg (f (x, y)) : _)).symm

lemma integrable.integral_prod_right [sigma_finite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) : integrable (Œª y, ‚à´ x, f (x, y) ‚àÇŒº) ŒΩ :=
hf.swap.integral_prod_left

/-! ### The Bochner integral on a product -/

variables [sigma_finite Œº]

lemma integral_prod_swap (f : Œ± √ó Œ≤ ‚Üí E)
  (hf : ae_strongly_measurable f (Œº.prod ŒΩ)) : ‚à´ z, f z.swap ‚àÇ(ŒΩ.prod Œº) = ‚à´ z, f z ‚àÇ(Œº.prod ŒΩ) :=
begin
  rw ‚Üê prod_swap at hf,
  rw [‚Üê integral_map measurable_swap.ae_measurable hf, prod_swap]
end

variables {E' : Type*} [normed_add_comm_group E'] [complete_space E'] [normed_space ‚Ñù E']

/-! Some rules about the sum/difference of double integrals. They follow from `integral_add`, but
  we separate them out as separate lemmas, because they involve quite some steps. -/

/-- Integrals commute with addition inside another integral. `F` can be any function. -/
lemma integral_fn_integral_add ‚¶Éf g : Œ± √ó Œ≤ ‚Üí E‚¶Ñ (F : E ‚Üí E')
  (hf : integrable f (Œº.prod ŒΩ)) (hg : integrable g (Œº.prod ŒΩ)) :
  ‚à´ x, F (‚à´ y, f (x, y) + g (x, y) ‚àÇŒΩ) ‚àÇŒº = ‚à´ x, F (‚à´ y, f (x, y) ‚àÇŒΩ + ‚à´ y, g (x, y) ‚àÇŒΩ) ‚àÇŒº :=
begin
  refine integral_congr_ae _,
  filter_upwards [hf.prod_right_ae, hg.prod_right_ae] with _ h2f h2g,
  simp [integral_add h2f h2g],
end

/-- Integrals commute with subtraction inside another integral.
  `F` can be any measurable function. -/
lemma integral_fn_integral_sub ‚¶Éf g : Œ± √ó Œ≤ ‚Üí E‚¶Ñ (F : E ‚Üí E')
  (hf : integrable f (Œº.prod ŒΩ)) (hg : integrable g (Œº.prod ŒΩ)) :
  ‚à´ x, F (‚à´ y, f (x, y) - g (x, y) ‚àÇŒΩ) ‚àÇŒº = ‚à´ x, F (‚à´ y, f (x, y) ‚àÇŒΩ - ‚à´ y, g (x, y) ‚àÇŒΩ) ‚àÇŒº :=
begin
  refine integral_congr_ae _,
  filter_upwards [hf.prod_right_ae, hg.prod_right_ae] with _ h2f h2g,
  simp [integral_sub h2f h2g],
end

/-- Integrals commute with subtraction inside a lower Lebesgue integral.
  `F` can be any function. -/
lemma lintegral_fn_integral_sub ‚¶Éf g : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (F : E ‚Üí ‚Ñù‚â•0‚àû) (hf : integrable f (Œº.prod ŒΩ)) (hg : integrable g (Œº.prod ŒΩ)) :
  ‚à´‚Åª x, F (‚à´ y, f (x, y) - g (x, y) ‚àÇŒΩ) ‚àÇŒº = ‚à´‚Åª x, F (‚à´ y, f (x, y) ‚àÇŒΩ - ‚à´ y, g (x, y) ‚àÇŒΩ) ‚àÇŒº :=
begin
  refine lintegral_congr_ae _,
  filter_upwards [hf.prod_right_ae, hg.prod_right_ae] with _ h2f h2g,
  simp [integral_sub h2f h2g],
end

/-- Double integrals commute with addition. -/
lemma integral_integral_add ‚¶Éf g : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) (hg : integrable g (Œº.prod ŒΩ)) :
  ‚à´ x, ‚à´ y, f (x, y) + g (x, y) ‚àÇŒΩ ‚àÇŒº = ‚à´ x, ‚à´ y, f (x, y) ‚àÇŒΩ ‚àÇŒº + ‚à´ x, ‚à´ y, g (x, y) ‚àÇŒΩ ‚àÇŒº :=
(integral_fn_integral_add id hf hg).trans $
  integral_add hf.integral_prod_left hg.integral_prod_left

/-- Double integrals commute with addition. This is the version with `(f + g) (x, y)`
  (instead of `f (x, y) + g (x, y)`) in the LHS. -/
lemma integral_integral_add' ‚¶Éf g : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) (hg : integrable g (Œº.prod ŒΩ)) :
  ‚à´ x, ‚à´ y, (f + g) (x, y) ‚àÇŒΩ ‚àÇŒº = ‚à´ x, ‚à´ y, f (x, y) ‚àÇŒΩ ‚àÇŒº + ‚à´ x, ‚à´ y, g (x, y) ‚àÇŒΩ ‚àÇŒº :=
integral_integral_add hf hg

/-- Double integrals commute with subtraction. -/
lemma integral_integral_sub ‚¶Éf g : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) (hg : integrable g (Œº.prod ŒΩ)) :
  ‚à´ x, ‚à´ y, f (x, y) - g (x, y) ‚àÇŒΩ ‚àÇŒº = ‚à´ x, ‚à´ y, f (x, y) ‚àÇŒΩ ‚àÇŒº - ‚à´ x, ‚à´ y, g (x, y) ‚àÇŒΩ ‚àÇŒº :=
(integral_fn_integral_sub id hf hg).trans $
  integral_sub hf.integral_prod_left hg.integral_prod_left

/-- Double integrals commute with subtraction. This is the version with `(f - g) (x, y)`
  (instead of `f (x, y) - g (x, y)`) in the LHS. -/
lemma integral_integral_sub' ‚¶Éf g : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) (hg : integrable g (Œº.prod ŒΩ)) :
  ‚à´ x, ‚à´ y, (f - g) (x, y) ‚àÇŒΩ ‚àÇŒº = ‚à´ x, ‚à´ y, f (x, y) ‚àÇŒΩ ‚àÇŒº - ‚à´ x, ‚à´ y, g (x, y) ‚àÇŒΩ ‚àÇŒº :=
integral_integral_sub hf hg

/-- The map that sends an L¬π-function `f : Œ± √ó Œ≤ ‚Üí E` to `‚à´‚à´f` is continuous. -/
lemma continuous_integral_integral :
  continuous (Œª (f : Œ± √ó Œ≤ ‚Üí‚ÇÅ[Œº.prod ŒΩ] E), ‚à´ x, ‚à´ y, f (x, y) ‚àÇŒΩ ‚àÇŒº) :=
begin
  rw [continuous_iff_continuous_at], intro g,
  refine tendsto_integral_of_L1 _ (L1.integrable_coe_fn g).integral_prod_left
    (eventually_of_forall $ Œª h, (L1.integrable_coe_fn h).integral_prod_left) _,
  simp_rw [‚Üê lintegral_fn_integral_sub (Œª x, (‚Äñx‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) (L1.integrable_coe_fn _)
    (L1.integrable_coe_fn g)],
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds _ (Œª i, zero_le _) _,
  { exact Œª i, ‚à´‚Åª x, ‚à´‚Åª y, ‚Äñi (x, y) - g (x, y)‚Äñ‚Çä ‚àÇŒΩ ‚àÇŒº },
  swap, { exact Œª i, lintegral_mono (Œª x, ennnorm_integral_le_lintegral_ennnorm _) },
  show tendsto (Œª (i : Œ± √ó Œ≤ ‚Üí‚ÇÅ[Œº.prod ŒΩ] E),
    ‚à´‚Åª x, ‚à´‚Åª (y : Œ≤), ‚Äñi (x, y) - g (x, y)‚Äñ‚Çä ‚àÇŒΩ ‚àÇŒº) (ùìù g) (ùìù 0),
  have : ‚àÄ (i : Œ± √ó Œ≤ ‚Üí‚ÇÅ[Œº.prod ŒΩ] E), measurable (Œª z, (‚Äñi z - g z‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) :=
  Œª i, ((Lp.strongly_measurable i).sub (Lp.strongly_measurable g)).ennnorm,
  simp_rw [‚Üê lintegral_prod_of_measurable _ (this _), ‚Üê L1.of_real_norm_sub_eq_lintegral,
    ‚Üê of_real_zero],
  refine (continuous_of_real.tendsto 0).comp _,
  rw [‚Üê tendsto_iff_norm_tendsto_zero], exact tendsto_id
end

/-- **Fubini's Theorem**: For integrable functions on `Œ± √ó Œ≤`,
  the Bochner integral of `f` is equal to the iterated Bochner integral.
  `integrable_prod_iff` can be useful to show that the function in question in integrable.
  `measure_theory.integrable.integral_prod_right` is useful to show that the inner integral
  of the right-hand side is integrable. -/
lemma integral_prod : ‚àÄ (f : Œ± √ó Œ≤ ‚Üí E) (hf : integrable f (Œº.prod ŒΩ)),
  ‚à´ z, f z ‚àÇ(Œº.prod ŒΩ) = ‚à´ x, ‚à´ y, f (x, y) ‚àÇŒΩ ‚àÇŒº :=
begin
  apply integrable.induction,
  { intros c s hs h2s,
    simp_rw [integral_indicator hs, ‚Üê indicator_comp_right,
      function.comp, integral_indicator (measurable_prod_mk_left hs),
      set_integral_const, integral_smul_const,
      integral_to_real (measurable_measure_prod_mk_left hs).ae_measurable
      (ae_measure_lt_top hs h2s.ne), prod_apply hs] },
  { intros f g hfg i_f i_g hf hg,
    simp_rw [integral_add' i_f i_g, integral_integral_add' i_f i_g, hf, hg] },
  { exact is_closed_eq continuous_integral continuous_integral_integral },
  { intros f g hfg i_f hf, convert hf using 1,
    { exact integral_congr_ae hfg.symm },
    { refine integral_congr_ae _,
      refine (ae_ae_of_ae_prod hfg).mp _,
      apply eventually_of_forall, intros x hfgx,
      exact integral_congr_ae (ae_eq_symm hfgx) } }
end

/-- Symmetric version of **Fubini's Theorem**: For integrable functions on `Œ± √ó Œ≤`,
  the Bochner integral of `f` is equal to the iterated Bochner integral.
  This version has the integrals on the right-hand side in the other order. -/
lemma integral_prod_symm (f : Œ± √ó Œ≤ ‚Üí E) (hf : integrable f (Œº.prod ŒΩ)) :
  ‚à´ z, f z ‚àÇ(Œº.prod ŒΩ) = ‚à´ y, ‚à´ x, f (x, y) ‚àÇŒº ‚àÇŒΩ :=
by { simp_rw [‚Üê integral_prod_swap f hf.ae_strongly_measurable], exact integral_prod _ hf.swap }

/-- Reversed version of **Fubini's Theorem**. -/
lemma integral_integral {f : Œ± ‚Üí Œ≤ ‚Üí E} (hf : integrable (uncurry f) (Œº.prod ŒΩ)) :
  ‚à´ x, ‚à´ y, f x y ‚àÇŒΩ ‚àÇŒº = ‚à´ z, f z.1 z.2 ‚àÇ(Œº.prod ŒΩ) :=
(integral_prod _ hf).symm

/-- Reversed version of **Fubini's Theorem** (symmetric version). -/
lemma integral_integral_symm {f : Œ± ‚Üí Œ≤ ‚Üí E} (hf : integrable (uncurry f) (Œº.prod ŒΩ)) :
  ‚à´ x, ‚à´ y, f x y ‚àÇŒΩ ‚àÇŒº = ‚à´ z, f z.2 z.1 ‚àÇ(ŒΩ.prod Œº) :=
(integral_prod_symm _ hf.swap).symm

/-- Change the order of Bochner integration. -/
lemma integral_integral_swap ‚¶Éf : Œ± ‚Üí Œ≤ ‚Üí E‚¶Ñ (hf : integrable (uncurry f) (Œº.prod ŒΩ)) :
  ‚à´ x, ‚à´ y, f x y ‚àÇŒΩ ‚àÇŒº = ‚à´ y, ‚à´ x, f x y ‚àÇŒº ‚àÇŒΩ :=
(integral_integral hf).trans (integral_prod_symm _ hf)

/-- **Fubini's Theorem** for set integrals. -/
lemma set_integral_prod (f : Œ± √ó Œ≤ ‚Üí E) {s : set Œ±} {t : set Œ≤}
  (hf : integrable_on f (s √óÀ¢ t) (Œº.prod ŒΩ)) :
  ‚à´ z in s √óÀ¢ t, f z ‚àÇ(Œº.prod ŒΩ) = ‚à´ x in s, ‚à´ y in t, f (x, y) ‚àÇŒΩ ‚àÇŒº :=
begin
  simp only [‚Üê measure.prod_restrict s t, integrable_on] at hf ‚ä¢,
  exact integral_prod f hf
end

lemma integral_prod_mul {L : Type*} [is_R_or_C L] (f : Œ± ‚Üí L) (g : Œ≤ ‚Üí L) :
  ‚à´ z, f z.1 * g z.2 ‚àÇ(Œº.prod ŒΩ) = (‚à´ x, f x ‚àÇŒº) * (‚à´ y, g y ‚àÇŒΩ) :=
begin
  by_cases h : integrable (Œª (z : Œ± √ó Œ≤), f z.1 * g z.2) (Œº.prod ŒΩ),
  { rw integral_prod _ h,
    simp_rw [integral_mul_left, integral_mul_right] },
  have H : ¬¨(integrable f Œº) ‚à® ¬¨(integrable g ŒΩ),
  { contrapose! h,
    exact integrable_prod_mul h.1 h.2 },
  cases H;
  simp [integral_undef h, integral_undef H],
end

lemma set_integral_prod_mul {L : Type*} [is_R_or_C L]
  (f : Œ± ‚Üí L) (g : Œ≤ ‚Üí L) (s : set Œ±) (t : set Œ≤) :
  ‚à´ z in s √óÀ¢ t, f z.1 * g z.2 ‚àÇ(Œº.prod ŒΩ) = (‚à´ x in s, f x ‚àÇŒº) * (‚à´ y in t, g y ‚àÇŒΩ) :=
by simp only [‚Üê measure.prod_restrict s t, integrable_on, integral_prod_mul]

end measure_theory
