/-
Copyright (c) 2021 S√©bastien Gou√´zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Yury Kudryashov, S√©bastien Gou√´zel
-/
import measure_theory.constructions.borel_space.basic
import topology.algebra.order.left_right_lim

/-!
# Stieltjes measures on the real line

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Consider a function `f : ‚Ñù ‚Üí ‚Ñù` which is monotone and right-continuous. Then one can define a
corrresponding measure, giving mass `f b - f a` to the interval `(a, b]`.

## Main definitions

* `stieltjes_function` is a structure containing a function from `‚Ñù ‚Üí ‚Ñù`, together with the
assertions that it is monotone and right-continuous. To `f : stieltjes_function`, one associates
a Borel measure `f.measure`.
* `f.measure_Ioc` asserts that `f.measure (Ioc a b) = of_real (f b - f a)`
* `f.measure_Ioo` asserts that `f.measure (Ioo a b) = of_real (left_lim f b - f a)`.
* `f.measure_Icc` and `f.measure_Ico` are analogous.
-/


section move_this
-- this section contains lemmas that should be moved to appropriate places after the port to lean 4

open filter set
open_locale topology

lemma infi_Ioi_eq_infi_rat_gt {f : ‚Ñù ‚Üí ‚Ñù} (x : ‚Ñù) (hf : bdd_below (f '' Ioi x))
  (hf_mono : monotone f) :
  (‚®Ö r : Ioi x, f r) = ‚®Ö q : {q' : ‚Ñö // x < q'}, f q :=
begin
  refine le_antisymm _ _,
  { haveI : nonempty {r' : ‚Ñö // x < ‚Üër'},
    { obtain ‚ü®r, hrx‚ü© := exists_rat_gt x,
      exact ‚ü®‚ü®r, hrx‚ü©‚ü©, },
    refine le_cinfi (Œª r, _),
    obtain ‚ü®y, hxy, hyr‚ü© := exists_rat_btwn r.prop,
    refine cinfi_set_le hf (hxy.trans _),
    exact_mod_cast hyr, },
  { refine le_cinfi (Œª q, _),
    have hq := q.prop,
    rw mem_Ioi at hq,
    obtain ‚ü®y, hxy, hyq‚ü© := exists_rat_btwn hq,
    refine (cinfi_le _ _).trans _,
    { exact ‚ü®y, hxy‚ü©, },
    { refine ‚ü®hf.some, Œª z, _‚ü©,
      rintros ‚ü®u, rfl‚ü©,
      suffices hfu : f u ‚àà f '' Ioi x, from hf.some_spec hfu,
      exact ‚ü®u, u.prop, rfl‚ü©, },
    { refine hf_mono (le_trans _ hyq.le),
      norm_cast, }, },
end

-- todo after the port: move to topology/algebra/order/left_right_lim
lemma right_lim_eq_of_tendsto {Œ± Œ≤ : Type*} [linear_order Œ±] [topological_space Œ≤]
  [hŒ± : topological_space Œ±] [h'Œ± : order_topology Œ±] [t2_space Œ≤]
  {f : Œ± ‚Üí Œ≤} {a : Œ±} {y : Œ≤} (h : ùìù[>] a ‚â† ‚ä•) (h' : tendsto f (ùìù[>] a) (ùìù y)) :
  function.right_lim f a = y :=
@left_lim_eq_of_tendsto Œ±·µí·µà _ _ _ _ _ _ f a y h h'

-- todo after the port: move to topology/algebra/order/left_right_lim
lemma right_lim_eq_Inf {Œ± Œ≤ : Type*} [linear_order Œ±] [topological_space Œ≤]
  [conditionally_complete_linear_order Œ≤] [order_topology Œ≤] {f : Œ± ‚Üí Œ≤}
  (hf : monotone f) {x : Œ±}
  [topological_space Œ±] [order_topology Œ±] (h : ùìù[>] x ‚â† ‚ä•) :
  function.right_lim f x = Inf (f '' (Ioi x)) :=
right_lim_eq_of_tendsto h (hf.tendsto_nhds_within_Ioi x)

-- todo after the port: move to order/filter/at_top_bot
lemma exists_seq_monotone_tendsto_at_top_at_top (Œ± : Type*) [semilattice_sup Œ±] [nonempty Œ±]
  [(at_top : filter Œ±).is_countably_generated] :
  ‚àÉ xs : ‚Ñï ‚Üí Œ±, monotone xs ‚àß tendsto xs at_top at_top :=
begin
  haveI h_ne_bot : (at_top : filter Œ±).ne_bot := at_top_ne_bot,
  obtain ‚ü®ys, h‚ü© := exists_seq_tendsto (at_top : filter Œ±),
  let xs : ‚Ñï ‚Üí Œ± := Œª n, finset.sup' (finset.range (n + 1)) finset.nonempty_range_succ ys,
  have h_mono : monotone xs,
  { intros i j hij,
    rw finset.sup'_le_iff,
    intros k hk,
    refine finset.le_sup'_of_le _ _ le_rfl,
    rw finset.mem_range at hk ‚ä¢,
    exact hk.trans_le (add_le_add_right hij _), },
  refine ‚ü®xs, h_mono, _‚ü©,
  { refine tendsto_at_top_at_top_of_monotone h_mono _,
    have : ‚àÄ (a : Œ±), ‚àÉ (n : ‚Ñï), a ‚â§ ys n,
    { rw tendsto_at_top_at_top at h,
      intro a,
      obtain ‚ü®i, hi‚ü© := h a,
      exact ‚ü®i, hi i le_rfl‚ü©, },
    intro a,
    obtain ‚ü®i, hi‚ü© := this a,
    refine ‚ü®i, hi.trans _‚ü©,
    refine finset.le_sup'_of_le _ _ le_rfl,
    rw finset.mem_range_succ_iff, },
end

lemma exists_seq_antitone_tendsto_at_top_at_bot (Œ± : Type*) [semilattice_inf Œ±] [nonempty Œ±]
  [h2 : (at_bot : filter Œ±).is_countably_generated] :
  ‚àÉ xs : ‚Ñï ‚Üí Œ±, antitone xs ‚àß tendsto xs at_top at_bot :=
@exists_seq_monotone_tendsto_at_top_at_top Œ±·µí·µà _ _ h2

-- todo after the port: move to topology/algebra/order/monotone_convergence
lemma supr_eq_supr_subseq_of_antitone {Œπ‚ÇÅ Œπ‚ÇÇ Œ± : Type*} [preorder Œπ‚ÇÇ] [complete_lattice Œ±]
  {l : filter Œπ‚ÇÅ} [l.ne_bot] {f : Œπ‚ÇÇ ‚Üí Œ±} {œÜ : Œπ‚ÇÅ ‚Üí Œπ‚ÇÇ} (hf : antitone f)
  (hœÜ : tendsto œÜ l at_bot) :
  (‚®Ü i, f i) = (‚®Ü i, f (œÜ i)) :=
le_antisymm
  (supr_mono' (Œª i, exists_imp_exists (Œª j (hj : œÜ j ‚â§ i), hf hj)
    (hœÜ.eventually $ eventually_le_at_bot i).exists))
  (supr_mono' (Œª i, ‚ü®œÜ i, le_rfl‚ü©))

namespace measure_theory
-- todo after the port: move these lemmas to measure_theory/measure/measure_space?
variables {Œ± : Type*} {mŒ± : measurable_space Œ±}
include mŒ±

lemma tendsto_measure_Ico_at_top [semilattice_sup Œ±] [no_max_order Œ±]
  [(at_top : filter Œ±).is_countably_generated] (Œº : measure Œ±) (a : Œ±) :
  tendsto (Œª x, Œº (Ico a x)) at_top (ùìù (Œº (Ici a))) :=
begin
  haveI : nonempty Œ± := ‚ü®a‚ü©,
  have h_mono : monotone (Œª x, Œº (Ico a x)) := Œª i j hij, measure_mono (Ico_subset_Ico_right hij),
  convert tendsto_at_top_supr h_mono,
  obtain ‚ü®xs, hxs_mono, hxs_tendsto‚ü© := exists_seq_monotone_tendsto_at_top_at_top Œ±,
  have h_Ici : Ici a = ‚ãÉ n, Ico a (xs n),
  { ext1 x,
    simp only [mem_Ici, mem_Union, mem_Ico, exists_and_distrib_left, iff_self_and],
    intro _,
    obtain ‚ü®y, hxy‚ü© := no_max_order.exists_gt x,
    obtain ‚ü®n, hn‚ü© := tendsto_at_top_at_top.mp hxs_tendsto y,
    exact ‚ü®n, hxy.trans_le (hn n le_rfl)‚ü©, },
  rw [h_Ici, measure_Union_eq_supr, supr_eq_supr_subseq_of_monotone h_mono hxs_tendsto],
  exact monotone.directed_le (Œª i j hij, Ico_subset_Ico_right (hxs_mono hij)),
end

lemma tendsto_measure_Ioc_at_bot [semilattice_inf Œ±] [no_min_order Œ±]
  [(at_bot : filter Œ±).is_countably_generated] (Œº : measure Œ±) (a : Œ±) :
  tendsto (Œª x, Œº (Ioc x a)) at_bot (ùìù (Œº (Iic a))) :=
begin
  haveI : nonempty Œ± := ‚ü®a‚ü©,
  have h_mono : antitone (Œª x, Œº (Ioc x a)) := Œª i j hij, measure_mono (Ioc_subset_Ioc_left hij),
  convert tendsto_at_bot_supr h_mono,
  obtain ‚ü®xs, hxs_mono, hxs_tendsto‚ü© := exists_seq_antitone_tendsto_at_top_at_bot Œ±,
  have h_Iic : Iic a = ‚ãÉ n, Ioc (xs n) a,
  { ext1 x,
    simp only [mem_Iic, mem_Union, mem_Ioc, exists_and_distrib_right, iff_and_self],
    intro _,
    obtain ‚ü®y, hxy‚ü© := no_min_order.exists_lt x,
    obtain ‚ü®n, hn‚ü© := tendsto_at_top_at_bot.mp hxs_tendsto y,
    exact ‚ü®n, (hn n le_rfl).trans_lt hxy‚ü©, },
  rw [h_Iic, measure_Union_eq_supr, supr_eq_supr_subseq_of_antitone h_mono hxs_tendsto],
  exact monotone.directed_le (Œª i j hij, Ioc_subset_Ioc_left (hxs_mono hij)),
end

lemma tendsto_measure_Iic_at_top [semilattice_sup Œ±] [(at_top : filter Œ±).is_countably_generated]
  (Œº : measure Œ±) :
  tendsto (Œª x, Œº (Iic x)) at_top (ùìù (Œº univ)) :=
begin
  casesI is_empty_or_nonempty Œ±,
  { have h1 : ‚àÄ x : Œ±, Iic x = ‚àÖ := Œª x, subsingleton.elim _ _,
    have h2 : (univ : set Œ±) = ‚àÖ := subsingleton.elim _ _,
    simp_rw [h1, h2],
    exact tendsto_const_nhds, },
  have h_mono : monotone (Œª x, Œº (Iic x)) := Œª i j hij, measure_mono (Iic_subset_Iic.mpr hij),
  convert tendsto_at_top_supr h_mono,
  obtain ‚ü®xs, hxs_mono, hxs_tendsto‚ü© := exists_seq_monotone_tendsto_at_top_at_top Œ±,
  have h_univ : (univ : set Œ±) = ‚ãÉ n, Iic (xs n),
  { ext1 x,
    simp only [mem_univ, mem_Union, mem_Iic, true_iff],
    obtain ‚ü®n, hn‚ü© := tendsto_at_top_at_top.mp hxs_tendsto x,
    exact ‚ü®n, hn n le_rfl‚ü©, },
  rw [h_univ, measure_Union_eq_supr, supr_eq_supr_subseq_of_monotone h_mono hxs_tendsto],
  exact monotone.directed_le (Œª i j hij, Iic_subset_Iic.mpr (hxs_mono hij)),
end

lemma tendsto_measure_Ici_at_bot [semilattice_inf Œ±]
  [h : (at_bot : filter Œ±).is_countably_generated] (Œº : measure Œ±) :
  tendsto (Œª x, Œº (Ici x)) at_bot (ùìù (Œº univ)) :=
@tendsto_measure_Iic_at_top Œ±·µí·µà _ _ h Œº

end measure_theory

end move_this


noncomputable theory
open classical set filter function
open ennreal (of_real)
open_locale big_operators ennreal nnreal topology measure_theory

/-! ### Basic properties of Stieltjes functions -/

/-- Bundled monotone right-continuous real functions, used to construct Stieltjes measures. -/
structure stieltjes_function :=
(to_fun : ‚Ñù ‚Üí ‚Ñù)
(mono' : monotone to_fun)
(right_continuous' : ‚àÄ x, continuous_within_at to_fun (Ici x) x)

namespace stieltjes_function

instance : has_coe_to_fun stieltjes_function (Œª _, ‚Ñù ‚Üí ‚Ñù) := ‚ü®to_fun‚ü©

initialize_simps_projections stieltjes_function (to_fun ‚Üí apply)

variable (f : stieltjes_function)

lemma mono : monotone f := f.mono'

lemma right_continuous (x : ‚Ñù) : continuous_within_at f (Ici x) x := f.right_continuous' x

lemma right_lim_eq (f : stieltjes_function) (x : ‚Ñù) :
  function.right_lim f x = f x :=
begin
  rw [‚Üê f.mono.continuous_within_at_Ioi_iff_right_lim_eq, continuous_within_at_Ioi_iff_Ici],
  exact f.right_continuous' x,
end

lemma infi_Ioi_eq (f : stieltjes_function) (x : ‚Ñù) :
  (‚®Ö r : Ioi x, f r) = f x :=
begin
  suffices : function.right_lim f x = ‚®Ö r : Ioi x, f r,
  { rw [‚Üê this, f.right_lim_eq], },
  rw [right_lim_eq_Inf f.mono, Inf_image'],
  rw ‚Üê ne_bot_iff,
  apply_instance,
end

lemma infi_rat_gt_eq (f : stieltjes_function) (x : ‚Ñù) :
  (‚®Ö r : {r' : ‚Ñö // x < r'}, f r) = f x :=
begin
  rw ‚Üê infi_Ioi_eq f x,
  refine (infi_Ioi_eq_infi_rat_gt _ _ f.mono).symm,
  refine ‚ü®f x, Œª y, _‚ü©,
  rintros ‚ü®y, hy_mem, rfl‚ü©,
  exact f.mono (le_of_lt hy_mem),
end

/-- The identity of `‚Ñù` as a Stieltjes function, used to construct Lebesgue measure. -/
@[simps] protected def id : stieltjes_function :=
{ to_fun := id,
  mono' := Œª x y, id,
  right_continuous' := Œª x, continuous_within_at_id }

@[simp] lemma id_left_lim (x : ‚Ñù) : left_lim stieltjes_function.id x = x :=
tendsto_nhds_unique (stieltjes_function.id.mono.tendsto_left_lim x) $
  (continuous_at_id).tendsto.mono_left nhds_within_le_nhds

instance : inhabited stieltjes_function := ‚ü®stieltjes_function.id‚ü©

/-- If a function `f : ‚Ñù ‚Üí ‚Ñù` is monotone, then the function mapping `x` to the right limit of `f`
at `x` is a Stieltjes function, i.e., it is monotone and right-continuous. -/
noncomputable def _root_.monotone.stieltjes_function {f : ‚Ñù ‚Üí ‚Ñù} (hf : monotone f) :
  stieltjes_function :=
{ to_fun := right_lim f,
  mono' := Œª x y hxy, hf.right_lim hxy,
  right_continuous' :=
  begin
    assume x s hs,
    obtain ‚ü®l, u, hlu, lus‚ü© : ‚àÉ (l u : ‚Ñù), right_lim f x ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
      mem_nhds_iff_exists_Ioo_subset.1 hs,
    obtain ‚ü®y, xy, h'y‚ü© : ‚àÉ (y : ‚Ñù) (H : x < y), Ioc x y ‚äÜ f ‚Åª¬π' (Ioo l u) :=
      mem_nhds_within_Ioi_iff_exists_Ioc_subset.1
        (hf.tendsto_right_lim x (Ioo_mem_nhds hlu.1 hlu.2)),
    change ‚àÄ·∂† y in ùìù[‚â•] x, right_lim f y ‚àà s,
    filter_upwards [Ico_mem_nhds_within_Ici ‚ü®le_refl x, xy‚ü©] with z hz,
    apply lus,
    refine ‚ü®hlu.1.trans_le (hf.right_lim hz.1), _‚ü©,
    obtain ‚ü®a, za, ay‚ü© : ‚àÉ (a : ‚Ñù), z < a ‚àß a < y := exists_between hz.2,
    calc right_lim f z ‚â§ f a : hf.right_lim_le za
                   ... < u   : (h'y ‚ü®hz.1.trans_lt za, ay.le‚ü©).2,
  end }

lemma _root_.monotone.stieltjes_function_eq {f : ‚Ñù ‚Üí ‚Ñù} (hf : monotone f) (x : ‚Ñù) :
  hf.stieltjes_function x = right_lim f x := rfl

lemma countable_left_lim_ne (f : stieltjes_function) :
  set.countable {x | left_lim f x ‚â† f x} :=
begin
  apply countable.mono _ (f.mono.countable_not_continuous_at),
  assume x hx h'x,
  apply hx,
  exact tendsto_nhds_unique (f.mono.tendsto_left_lim x) (h'x.tendsto.mono_left nhds_within_le_nhds),
end


/-! ### The outer measure associated to a Stieltjes function -/

/-- Length of an interval. This is the largest monotone function which correctly measures all
intervals. -/
def length (s : set ‚Ñù) : ‚Ñù‚â•0‚àû := ‚®Öa b (h : s ‚äÜ Ioc a b), of_real (f b - f a)

@[simp] lemma length_empty : f.length ‚àÖ = 0 :=
nonpos_iff_eq_zero.1 $ infi_le_of_le 0 $ infi_le_of_le 0 $ by simp

@[simp] lemma length_Ioc (a b : ‚Ñù) :
  f.length (Ioc a b) = of_real (f b - f a) :=
begin
  refine le_antisymm (infi_le_of_le a $ infi‚ÇÇ_le b subset.rfl)
    (le_infi $ Œª a', le_infi $ Œª b', le_infi $ Œª h, ennreal.coe_le_coe.2 _),
  cases le_or_lt b a with ab ab,
  { rw real.to_nnreal_of_nonpos (sub_nonpos.2 (f.mono ab)), apply zero_le, },
  cases (Ioc_subset_Ioc_iff ab).1 h with h‚ÇÅ h‚ÇÇ,
  exact real.to_nnreal_le_to_nnreal (sub_le_sub (f.mono h‚ÇÅ) (f.mono h‚ÇÇ))
end

lemma length_mono {s‚ÇÅ s‚ÇÇ : set ‚Ñù} (h : s‚ÇÅ ‚äÜ s‚ÇÇ) : f.length s‚ÇÅ ‚â§ f.length s‚ÇÇ :=
infi_mono $ Œª a, binfi_mono $ Œª b, h.trans

open measure_theory

/-- The Stieltjes outer measure associated to a Stieltjes function. -/
protected def outer : outer_measure ‚Ñù :=
outer_measure.of_function f.length f.length_empty

lemma outer_le_length (s : set ‚Ñù) : f.outer s ‚â§ f.length s :=
outer_measure.of_function_le _

/-- If a compact interval `[a, b]` is covered by a union of open interval `(c i, d i)`, then
`f b - f a ‚â§ ‚àë f (d i) - f (c i)`. This is an auxiliary technical statement to prove the same
statement for half-open intervals, the point of the current statement being that one can use
compactness to reduce it to a finite sum, and argue by induction on the size of the covering set. -/
lemma length_subadditive_Icc_Ioo {a b : ‚Ñù} {c d : ‚Ñï ‚Üí ‚Ñù}
  (ss : Icc a b ‚äÜ ‚ãÉ i, Ioo (c i) (d i)) :
  of_real (f b - f a) ‚â§ ‚àë' i, of_real (f (d i) - f (c i)) :=
begin
  suffices : ‚àÄ (s:finset ‚Ñï) b
    (cv : Icc a b ‚äÜ ‚ãÉ i ‚àà (‚Üës:set ‚Ñï), Ioo (c i) (d i)),
    (of_real (f b - f a) : ‚Ñù‚â•0‚àû) ‚â§ ‚àë i in s, of_real (f (d i) - f (c i)),
  { rcases is_compact_Icc.elim_finite_subcover_image (Œª (i : ‚Ñï) (_ : i ‚àà univ),
      @is_open_Ioo _ _ _ _ (c i) (d i)) (by simpa using ss) with ‚ü®s, su, hf, hs‚ü©,
    have e : (‚ãÉ i ‚àà (‚Üëhf.to_finset:set ‚Ñï), Ioo (c i) (d i)) = (‚ãÉ i ‚àà s, Ioo (c i) (d i)),
      by simp only [ext_iff, exists_prop, finset.set_bUnion_coe, mem_Union, forall_const, iff_self,
                    finite.mem_to_finset],
    rw ennreal.tsum_eq_supr_sum,
    refine le_trans _ (le_supr _ hf.to_finset),
    exact this hf.to_finset _ (by simpa only [e]) },
  clear ss b,
  refine Œª s, finset.strong_induction_on s (Œª s IH b cv, _),
  cases le_total b a with ab ab,
  { rw ennreal.of_real_eq_zero.2 (sub_nonpos.2 (f.mono ab)), exact zero_le _, },
  have := cv ‚ü®ab, le_rfl‚ü©, simp at this,
  rcases this with ‚ü®i, is, cb, bd‚ü©,
  rw [‚Üê finset.insert_erase is] at cv ‚ä¢,
  rw [finset.coe_insert, bUnion_insert] at cv,
  rw [finset.sum_insert (finset.not_mem_erase _ _)],
  refine le_trans _ (add_le_add_left (IH _ (finset.erase_ssubset is) (c i) _) _),
  { refine le_trans (ennreal.of_real_le_of_real _) ennreal.of_real_add_le,
    rw sub_add_sub_cancel,
    exact sub_le_sub_right (f.mono bd.le) _ },
  { rintro x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©,
    refine (cv ‚ü®h‚ÇÅ, le_trans h‚ÇÇ (le_of_lt cb)‚ü©).resolve_left
      (mt and.left (not_lt_of_le h‚ÇÇ)) }
end

@[simp] lemma outer_Ioc (a b : ‚Ñù) :
  f.outer (Ioc a b) = of_real (f b - f a) :=
begin
  /- It suffices to show that, if `(a, b]` is covered by sets `s i`, then `f b - f a` is bounded
  by `‚àë f.length (s i) + Œµ`. The difficulty is that `f.length` is expressed in terms of half-open
  intervals, while we would like to have a compact interval covered by open intervals to use
  compactness and finite sums, as provided by `length_subadditive_Icc_Ioo`. The trick is to use the
  right-continuity of `f`. If `a'` is close enough to `a` on its right, then `[a', b]` is still
  covered by the sets `s i` and moreover `f b - f a'` is very close to `f b - f a` (up to `Œµ/2`).
  Also, by definition one can cover `s i` by a half-closed interval `(p i, q i]` with `f`-length
  very close to  that of `s i` (within a suitably small `Œµ' i`, say). If one moves `q i` very
  slightly to the right, then the `f`-length will change very little by right continuity, and we
  will get an open interval `(p i, q' i)` covering `s i` with `f (q' i) - f (p i)` within `Œµ' i`
  of the `f`-length of `s i`. -/
  refine le_antisymm (by { rw ‚Üê f.length_Ioc, apply outer_le_length })
    (le_infi‚ÇÇ $ Œª s hs, ennreal.le_of_forall_pos_le_add $ Œª Œµ Œµpos h, _),
  let Œ¥ := Œµ / 2,
  have Œ¥pos : 0 < (Œ¥ : ‚Ñù‚â•0‚àû), by simpa using Œµpos.ne',
  rcases ennreal.exists_pos_sum_of_countable Œ¥pos.ne' ‚Ñï with ‚ü®Œµ', Œµ'0, hŒµ‚ü©,
  obtain ‚ü®a', ha', aa'‚ü© : ‚àÉ a', f a' - f a < Œ¥ ‚àß a < a',
  { have A : continuous_within_at (Œª r, f r - f a) (Ioi a) a,
    { refine continuous_within_at.sub _ continuous_within_at_const,
      exact (f.right_continuous a).mono Ioi_subset_Ici_self },
    have B : f a - f a < Œ¥, by rwa [sub_self, nnreal.coe_pos, ‚Üê ennreal.coe_pos],
    exact (((tendsto_order.1 A).2 _ B).and self_mem_nhds_within).exists },
  have : ‚àÄ i, ‚àÉ p:‚Ñù√ó‚Ñù, s i ‚äÜ Ioo p.1 p.2 ‚àß
                        (of_real (f p.2 - f p.1) : ‚Ñù‚â•0‚àû) < f.length (s i) + Œµ' i,
  { intro i,
    have := (ennreal.lt_add_right ((ennreal.le_tsum i).trans_lt h).ne
        (ennreal.coe_ne_zero.2 (Œµ'0 i).ne')),
    conv at this { to_lhs, rw length },
    simp only [infi_lt_iff, exists_prop] at this,
    rcases this with ‚ü®p, q', spq, hq'‚ü©,
    have : continuous_within_at (Œª r, of_real (f r - f p)) (Ioi q') q',
    { apply ennreal.continuous_of_real.continuous_at.comp_continuous_within_at,
      refine continuous_within_at.sub _ continuous_within_at_const,
      exact (f.right_continuous q').mono Ioi_subset_Ici_self },
    rcases (((tendsto_order.1 this).2 _ hq').and self_mem_nhds_within).exists with ‚ü®q, hq, q'q‚ü©,
    exact ‚ü®‚ü®p, q‚ü©, spq.trans (Ioc_subset_Ioo_right q'q), hq‚ü© },
  choose g hg using this,
  have I_subset : Icc a' b ‚äÜ ‚ãÉ i, Ioo (g i).1 (g i).2 := calc
    Icc a' b ‚äÜ Ioc a b : Œª x hx, ‚ü®aa'.trans_le hx.1, hx.2‚ü©
    ... ‚äÜ ‚ãÉ i, s i : hs
    ... ‚äÜ ‚ãÉ i, Ioo (g i).1 (g i).2 : Union_mono (Œª i, (hg i).1),
  calc of_real (f b - f a)
      = of_real ((f b - f a') + (f a' - f a)) : by rw sub_add_sub_cancel
  ... ‚â§ of_real (f b - f a') + of_real (f a' - f a) : ennreal.of_real_add_le
  ... ‚â§ (‚àë' i, of_real (f (g i).2 - f (g i).1)) + of_real Œ¥ :
    add_le_add (f.length_subadditive_Icc_Ioo I_subset) (ennreal.of_real_le_of_real ha'.le)
  ... ‚â§ (‚àë' i, (f.length (s i) + Œµ' i)) + Œ¥ :
    add_le_add (ennreal.tsum_le_tsum (Œª i, (hg i).2.le))
      (by simp only [ennreal.of_real_coe_nnreal, le_rfl])
  ... = (‚àë' i, f.length (s i)) + (‚àë' i, Œµ' i) + Œ¥ : by rw [ennreal.tsum_add]
  ... ‚â§ (‚àë' i, f.length (s i)) + Œ¥ + Œ¥ : add_le_add (add_le_add le_rfl hŒµ.le) le_rfl
  ... = ‚àë' (i : ‚Ñï), f.length (s i) + Œµ : by simp [add_assoc, ennreal.add_halves]
end

lemma measurable_set_Ioi {c : ‚Ñù} :
  measurable_set[f.outer.caratheodory] (Ioi c) :=
begin
  apply outer_measure.of_function_caratheodory (Œª t, _),
  refine le_infi (Œª a, le_infi (Œª b, le_infi (Œª h, _))),
  refine le_trans (add_le_add
    (f.length_mono $ inter_subset_inter_left _ h)
    (f.length_mono $ diff_subset_diff_left h)) _,
  cases le_total a c with hac hac; cases le_total b c with hbc hbc,
  { simp only [Ioc_inter_Ioi, f.length_Ioc, hac, sup_eq_max, hbc, le_refl, Ioc_eq_empty,
      max_eq_right, min_eq_left, Ioc_diff_Ioi, f.length_empty, zero_add, not_lt] },
  { simp only [hac, hbc, Ioc_inter_Ioi, Ioc_diff_Ioi, f.length_Ioc, min_eq_right,
      sup_eq_max, ‚Üêennreal.of_real_add, f.mono hac, f.mono hbc, sub_nonneg, sub_add_sub_cancel,
      le_refl, max_eq_right] },
  { simp only [hbc, le_refl, Ioc_eq_empty, Ioc_inter_Ioi, min_eq_left, Ioc_diff_Ioi,
      f.length_empty, zero_add, or_true, le_sup_iff, f.length_Ioc, not_lt] },
  { simp only [hac, hbc, Ioc_inter_Ioi, Ioc_diff_Ioi, f.length_Ioc, min_eq_right,
      sup_eq_max, le_refl, Ioc_eq_empty, add_zero, max_eq_left, f.length_empty, not_lt] }
end

theorem outer_trim : f.outer.trim = f.outer :=
begin
  refine le_antisymm (Œª s, _) (outer_measure.le_trim _),
  rw outer_measure.trim_eq_infi,
  refine le_infi (Œª t, le_infi $ Œª ht,
    ennreal.le_of_forall_pos_le_add $ Œª Œµ Œµ0 h, _),
  rcases ennreal.exists_pos_sum_of_countable
    (ennreal.coe_pos.2 Œµ0).ne' ‚Ñï with ‚ü®Œµ', Œµ'0, hŒµ‚ü©,
  refine le_trans _ (add_le_add_left (le_of_lt hŒµ) _),
  rw ‚Üê ennreal.tsum_add,
  choose g hg using show
    ‚àÄ i, ‚àÉ s, t i ‚äÜ s ‚àß measurable_set s ‚àß
      f.outer s ‚â§ f.length (t i) + of_real (Œµ' i),
  { intro i,
    have := (ennreal.lt_add_right ((ennreal.le_tsum i).trans_lt h).ne
        (ennreal.coe_pos.2 (Œµ'0 i)).ne'),
    conv at this {to_lhs, rw length},
    simp only [infi_lt_iff] at this,
    rcases this with ‚ü®a, b, h‚ÇÅ, h‚ÇÇ‚ü©,
    rw ‚Üê f.outer_Ioc at h‚ÇÇ,
    exact ‚ü®_, h‚ÇÅ, measurable_set_Ioc, le_of_lt $ by simpa using h‚ÇÇ‚ü© },
  simp at hg,
  apply infi_le_of_le (Union g) _,
  apply infi_le_of_le (ht.trans $ Union_mono (Œª i, (hg i).1)) _,
  apply infi_le_of_le (measurable_set.Union (Œª i, (hg i).2.1)) _,
  exact le_trans (f.outer.Union _) (ennreal.tsum_le_tsum $ Œª i, (hg i).2.2)
end

lemma borel_le_measurable : borel ‚Ñù ‚â§ f.outer.caratheodory :=
begin
  rw borel_eq_generate_from_Ioi,
  refine measurable_space.generate_from_le _,
  simp [f.measurable_set_Ioi] { contextual := tt }
end

/-! ### The measure associated to a Stieltjes function -/

/-- The measure associated to a Stieltjes function, giving mass `f b - f a` to the
interval `(a, b]`. -/
@[irreducible] protected def measure : measure ‚Ñù :=
{ to_outer_measure := f.outer,
  m_Union := Œª s hs, f.outer.Union_eq_of_caratheodory $
    Œª i, f.borel_le_measurable _ (hs i),
  trimmed := f.outer_trim }

@[simp] lemma measure_Ioc (a b : ‚Ñù) : f.measure (Ioc a b) = of_real (f b - f a) :=
by { rw stieltjes_function.measure, exact f.outer_Ioc a b }

@[simp] lemma measure_singleton (a : ‚Ñù) : f.measure {a} = of_real (f a - left_lim f a) :=
begin
  obtain ‚ü®u, u_mono, u_lt_a, u_lim‚ü© : ‚àÉ (u : ‚Ñï ‚Üí ‚Ñù), strict_mono u ‚àß (‚àÄ (n : ‚Ñï), u n < a)
    ‚àß tendsto u at_top (ùìù a) := exists_seq_strict_mono_tendsto a,
  have A : {a} = ‚ãÇ n, Ioc (u n) a,
  { refine subset.antisymm (Œª x hx, by simp [mem_singleton_iff.1 hx, u_lt_a]) (Œª x hx, _),
    simp at hx,
    have : a ‚â§ x := le_of_tendsto' u_lim (Œª n, (hx n).1.le),
    simp [le_antisymm this (hx 0).2] },
  have L1 : tendsto (Œª n, f.measure (Ioc (u n) a)) at_top (ùìù (f.measure {a})),
  { rw A,
    refine tendsto_measure_Inter (Œª n, measurable_set_Ioc) (Œª m n hmn, _) _,
    { exact Ioc_subset_Ioc (u_mono.monotone hmn) le_rfl },
    { exact ‚ü®0, by simpa only [measure_Ioc] using ennreal.of_real_ne_top‚ü© } },
  have L2 : tendsto (Œª n, f.measure (Ioc (u n) a)) at_top (ùìù (of_real (f a - left_lim f a))),
  { simp only [measure_Ioc],
    have : tendsto (Œª n, f (u n)) at_top (ùìù (left_lim f a)),
    { apply (f.mono.tendsto_left_lim a).comp,
      exact tendsto_nhds_within_of_tendsto_nhds_of_eventually_within _ u_lim
        (eventually_of_forall (Œª n, u_lt_a n)) },
    exact ennreal.continuous_of_real.continuous_at.tendsto.comp (tendsto_const_nhds.sub this) },
  exact tendsto_nhds_unique L1 L2
end

@[simp] lemma measure_Icc (a b : ‚Ñù) : f.measure (Icc a b) = of_real (f b - left_lim f a) :=
begin
  rcases le_or_lt a b with hab|hab,
  { have A : disjoint {a} (Ioc a b), by simp,
    simp [‚Üê Icc_union_Ioc_eq_Icc le_rfl hab, -singleton_union, ‚Üê ennreal.of_real_add,
      f.mono.left_lim_le, measure_union A measurable_set_Ioc, f.mono hab] },
  { simp only [hab, measure_empty, Icc_eq_empty, not_le],
    symmetry,
    simp [ennreal.of_real_eq_zero, f.mono.le_left_lim hab] }
end

@[simp] lemma measure_Ioo {a b : ‚Ñù} : f.measure (Ioo a b) = of_real (left_lim f b - f a) :=
begin
  rcases le_or_lt b a with hab|hab,
  { simp only [hab, measure_empty, Ioo_eq_empty, not_lt],
    symmetry,
    simp [ennreal.of_real_eq_zero, f.mono.left_lim_le hab] },
  { have A : disjoint (Ioo a b) {b}, by simp,
    have D : f b - f a = (f b - left_lim f b) + (left_lim f b - f a), by abel,
    have := f.measure_Ioc a b,
    simp only [‚ÜêIoo_union_Icc_eq_Ioc hab le_rfl, measure_singleton,
      measure_union A (measurable_set_singleton b), Icc_self] at this,
    rw [D, ennreal.of_real_add, add_comm] at this,
    { simpa only [ennreal.add_right_inj ennreal.of_real_ne_top] },
    { simp only [f.mono.left_lim_le, sub_nonneg] },
    { simp only [f.mono.le_left_lim hab, sub_nonneg] } },
end

@[simp] lemma measure_Ico (a b : ‚Ñù) : f.measure (Ico a b) = of_real (left_lim f b - left_lim f a) :=
begin
  rcases le_or_lt b a with hab|hab,
  { simp only [hab, measure_empty, Ico_eq_empty, not_lt],
    symmetry,
    simp [ennreal.of_real_eq_zero, f.mono.left_lim hab] },
  { have A : disjoint {a} (Ioo a b) := by simp,
    simp [‚Üê Icc_union_Ioo_eq_Ico le_rfl hab, -singleton_union, hab.ne, f.mono.left_lim_le,
      measure_union A measurable_set_Ioo, f.mono.le_left_lim hab, ‚Üê ennreal.of_real_add] }
end

lemma measure_Iic {l : ‚Ñù} (hf : tendsto f at_bot (ùìù l)) (x : ‚Ñù) :
  f.measure (Iic x) = of_real (f x - l) :=
begin
  refine tendsto_nhds_unique (tendsto_measure_Ioc_at_bot _ _) _,
  simp_rw measure_Ioc,
  exact ennreal.tendsto_of_real (tendsto.const_sub _ hf),
end

lemma measure_Ici {l : ‚Ñù} (hf : tendsto f at_top (ùìù l)) (x : ‚Ñù) :
  f.measure (Ici x) = of_real (l - left_lim f x) :=
begin
  refine tendsto_nhds_unique (tendsto_measure_Ico_at_top _ _) _,
  simp_rw measure_Ico,
  refine ennreal.tendsto_of_real (tendsto.sub_const _ _),
  have h_le1 : ‚àÄ x, f (x - 1) ‚â§ left_lim f x := Œª x, monotone.le_left_lim f.mono (sub_one_lt x),
  have h_le2 : ‚àÄ x, left_lim f x ‚â§ f x := Œª x, monotone.left_lim_le f.mono le_rfl,
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le (hf.comp _) hf h_le1 h_le2,
  rw tendsto_at_top_at_top,
  exact Œª y, ‚ü®y + 1, Œª z hyz, by rwa le_sub_iff_add_le‚ü©,
end

lemma measure_univ {l u : ‚Ñù} (hfl : tendsto f at_bot (ùìù l)) (hfu : tendsto f at_top (ùìù u)) :
  f.measure univ = of_real (u - l) :=
begin
  refine tendsto_nhds_unique (tendsto_measure_Iic_at_top _) _,
  simp_rw measure_Iic f hfl,
  exact ennreal.tendsto_of_real (tendsto.sub_const hfu _),
end

instance : is_locally_finite_measure f.measure :=
‚ü®Œª x, ‚ü®Ioo (x-1) (x+1), Ioo_mem_nhds (by linarith) (by linarith), by simp‚ü©‚ü©

end stieltjes_function
